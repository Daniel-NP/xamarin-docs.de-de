|Eigenschaft|Beschreibung|Optionen|
|--- |--- |--- |
|`abi.type`|**ABI-Typ** &ndash; gibt den Typ der ABI (Application binary Interface) des emulierten Geräts. Die **X86** Option ist für den Anweisungssatz, der häufig als "X86" oder "IA-32" bezeichnet Die **x86_64** Option ist für die 64-Bit-X86-Anweisungssatz. Die **Armeabi-v7a** Option ist für den ARM-Anweisungssatz mit v7-a-ARM-Erweiterungen. Die **arm64-v8a** Option eignet sich für den ARM-Anweisungssatz, der AArch64 unterstützt.|x86, x86_64, armeabi-v7a, arm64-v8a|
|`disk.cachePartition`|**Cachepartition** &ndash; bestimmt, ob das emulierte Gerät einen **/cache** -Partition auf dem Gerät. Die **/cache** -Partition (anfänglich leer ist) ist der Speicherort, in denen Android, häufig verwendete Daten und app-Komponenten speichert. Wenn auf festgelegt **keine**, der Emulator wird nicht verwendet. eine **/cache** Partition und die andere `disk.cache` dateikonfigurationseinstellungen werden ignoriert.|yes, no|
|`disk.cachePartition.path`|**Pfad der cachepartition** &ndash; gibt an, auf dem Entwicklungscomputer als Partition-Image eine Cachedatei. Der Emulator verwendet diese Datei für die **/cache** Partition. Geben Sie einen absoluten Pfad oder einen Pfad relativ zum Datenverzeichnis des Emulators. Wenn nicht festgelegt ist, der Emulator eine leere temporäre Datei namens erstellt **cache.img** auf Ihrem Entwicklungscomputer. Wenn die Datei noch nicht vorhanden ist, wird sie als leere Datei erstellt. Diese Option wird ignoriert, wenn `disk.cachePartition` nastaven NA hodnotu **keine**.||
|`disk.cachePartition.size`|**Cachegröße für die Partition** &ndash; die Größe der cachepartitionsdatei (in Byte). Normalerweise müssen Sie diese Option nur dann festlegen, wenn die App sehr große Dateien herunterlädt, die die Standardgröße des Caches von 66 Megabyte übersteigen. Diese Option wird ignoriert, wenn `disk.cachePartition` nastaven NA hodnotu **keine**. Wenn dieser Wert eine ganze Zahl ist, gibt es die Größe in Bytes. Sie können auch die Größe in Kilobyte, Megabyte oder Gigabyte angeben, durch Anfügen **K**, **M**, oder **G** auf den Wert. Die minimale Größe beträgt **9 Min.** und die maximale Größe beträgt **1023 GB**.||
|`disk.dataPartition.initPath`|**Ursprünglicher Pfad zur Datenpartition** &ndash; gibt die ursprünglichen Inhalte der Datenpartition. Nach dem Zurücksetzen der Benutzerdaten kopiert der Emulator den Inhalt der angegebenen Datei auf Benutzerdaten (standardmäßig **Userdata-qemu.img**) anstelle von **userdata.img** als die erste Version.||
|`disk.dataPartition.path`|**Pfad zur Datenpartition** &ndash; gibt die Partitionsdatei für Benutzerdaten. Geben Sie einen Dateinamen und einen Pfad auf Ihrem Entwicklungscomputer ein, um eine permanente Datei für Benutzerdaten zu konfigurieren. Wenn die Datei nicht vorhanden ist, erstellt der Emulator ein Image der Standarddatei **userdata.img**, speichert sie in dem vom angegebenen Dateinamen `disk.dataPartition.path`, und behält die Benutzerdaten, wenn der Emulator heruntergefahren. Wenn Sie keinen Pfad angeben, gibt die standardmäßige Datei heißt **Userdata-qemu.img**. Der spezielle Wert **<temp>** bewirkt, dass den Emulator zum Erstellen und verwenden eine temporäre Datei. Wenn `disk.dataPartition.initPath` festgelegt ist, wird der Inhalt kopiert wird die `disk.dataPartition.path` Datei beim Systemstart. Beachten Sie, dass diese Option nicht leer bleiben darf.||
|`disk.dataPartition.size`|**Größe der Datenpartition** &ndash; gibt die Größe der Partition für Benutzerdaten in Bytes. Wenn dieser Wert eine ganze Zahl ist, gibt es die Größe in Bytes. Sie können auch die Größe in Kilobyte, Megabyte oder Gigabyte angeben, durch Anfügen **K**, **M**, oder **G** auf den Wert. Die minimale Größe beträgt **9 Min.** und die maximale Größe beträgt **1023 GB**.||
|`disk.ramdisk.path`|**RAMDisk-Pfad** &ndash; Pfad für das Startimage für die Partition (Ramdisk). Das RAMDISK-Image ist eine Teilmenge des Systemimages, das vom Kernel geladen wird, bevor das Systemimage eingebunden wird. Das RAMDISK-Image enthält üblicherweise die Binärdateien für die Startzeit und Initialisierungsskripts. Wenn diese Option nicht angegeben ist, wird der Standardwert ist **ramdisk.img** im Systemverzeichnis Emulators.||
|`disk.snapStorage.path`|**Momentaufnahme-Speicherpfad** &ndash; Pfad zu der Speicherdatei für Momentaufnahmen, in dem alle Momentaufnahmen gespeichert werden. Alle Momentaufnahmen, die während der Ausführung aufgenommen werden, werden in dieser Datei gespeichert. Nur Momentaufnahmen, die in dieser Datei gespeichert werden, können während der Ausführung des Emulators wiederhergestellt werden. Wenn diese Option nicht angegeben wird, ist die Standardeinstellung snapshots.img im Datenverzeichnis Emulators.||
|`disk.systemPartition.initPath`|**Pfad der Systempartition Init** &ndash; Pfad zur schreibgeschützten Kopie der Datei des Betriebssystemimages; insbesondere Partition, die die Systembibliotheken und die Daten, die für die API-Ebene und sämtliche Varianten enthält. Wenn dieser Pfad nicht angegeben wird, ist die Standardeinstellung system.img im Systemverzeichnis Emulators.||
|`disk.systemPartition.path`|**Pfad der Systempartition** &ndash; Pfad zum Image Schreib-/System-Partition. Wenn dieser Pfad nicht festgelegt ist, eine temporäre Datei wird erstellt und initialisiert aus dem Inhalt der Datei anhand des `disk.systemPartition.initPath`.||
|`disk.systemPartition.size`|**Größe für die Systempartition** &ndash; die ideale Größe der Systempartition (in Byte). Diese Größenangabe wird ignoriert, wenn die tatsächliche Größe des Images der Systempartition diese Einstellung übersteigt. Andernfalls wird die maximale Größe angegeben, die die Systempartitionsdatei erreichen kann. Wenn dieser Wert eine ganze Zahl ist, gibt es die Größe in Bytes. Sie können auch die Größe in Kilobyte, Megabyte oder Gigabyte angeben, durch Anfügen **K**, **M**, oder **G** auf den Wert. Die minimale Größe beträgt **9 Min.** und die maximale Größe beträgt **1023 GB**.||
|`hw.accelerometer`|**Beschleunigungsmesser** &ndash; bestimmt, ob das emulierte Gerät einen Sensor für beschleunigungsmessung enthält. Der Beschleunigungsmesser unterstützt das Gerät bei der Orientierung (z.B. für die automatische Drehung). Der Beschleunigungsmesser meldet die Beschleunigung des Geräts an drei Sensorachsen.|yes, no|
|`hw.audioInput`|**Unterstützung der audioaufzeichnung** &ndash; bestimmt, ob das emulierte Gerät Audio aufzeichnen kann.|yes, no|
|`hw.audioOutput`|**Unterstützung der Audiowiedergabe** &ndash; bestimmt, ob das emulierte Gerät audio wiedergeben kann.|yes, no|
|`hw.battery`|**Unterstützung der Akku** &ndash; bestimmt, ob das emulierte Gerät im Akkubetrieb ausgeführt werden kann.|yes, no|
|`hw.camera`|**Kameraunterstützung** &ndash; bestimmt, ob das emulierte Gerät über eine Kamera verfügt.|yes, no|
|`hw.camera.back`|**Hintere Kamera** &ndash; konfiguriert die hintere Kamera (der Fokus vom Benutzer abgewandt). Wenn Sie eine Webcam auf Ihrem Entwicklungscomputer verwenden, um die hintere Kamera auf dem emulierten Gerät zu simulieren, muss dieser Wert festgelegt werden, um Webcam*n*, wobei _n_ wählt die Webcam, (Wenn Sie nur eine Webcam haben Wählen Sie **webcam0**). Wenn die emuliert wird auf festgelegt ist, simuliert der Emulator die Kamera in der Software. Um die hintere Kamera zu deaktivieren, legen Sie diesen Wert auf "None". Wenn Sie die hintere Kamera aktivieren, müssen Sie auch aktivieren, `hw.camera`.|emulated, none, webcam0|
|`hw.camera.front`|**Vordere Kamera** &ndash; konfiguriert die vordere Kamera (der Fokus ist dem Benutzer zugewandt). Wenn Sie eine Webcam auf Ihrem Entwicklungscomputer verwenden, um die vordere Kamera auf dem emulierten Gerät zu simulieren, muss dieser Wert festgelegt werden, um Webcam*n*, wobei _n_ wählt die Webcam, (Wenn Sie nur eine Webcam besitzen Wählen Sie **webcam0**). Wenn die emuliert wird auf festgelegt ist, simuliert der Emulator eine Kamera in der Software. Um die vordere Kamera zu deaktivieren, legen Sie diesen Wert auf "None". Wenn Sie die vordere Kamera aktivieren, müssen Sie auch aktivieren, `hw.camera`.|emulated, none, webcam0|
|`hw.camera.maxHorizontalPixels`|**Maximale horizontale Pixel der Kamera** &ndash; konfiguriert die maximale horizontale Auflösung der Kamera des emulierten Geräts, (in Pixel).||
|`hw.camera.maxVerticalPixels`|**Maximale vertikale Pixel der Kamera** &ndash; konfiguriert die maximale vertikale Auflösung der Kamera des emulierten Geräts, (in Pixel).||
|`hw.cpu.arch`|**CPU-Architektur** &ndash; der CPU-Architektur, die vom virtuellen Gerät emuliert werden. Wenn Sie Intel HAXM zur Hardwarebeschleunigung verwenden, wählen Sie **X86** für eine 32-Bit-CPU. Wählen Sie **x86_64** für ein Gerät für die 64-Bit-HAXM-Beschleunigung. (Achten Sie darauf, dass Sie das entsprechende Intel X86-Systemimage im SDK-Manager installieren: z. B. Intel X86 Atom oder Intel X86 Atom_64.) Wählen Sie eine ARM-CPU zu simulieren, **Arm** für 32-Bit- oder select **arm64** für eine 64-Bit-ARM-CPU. Bedenken Sie, dass auf ARM basierende virtuelle Geräte langsamer ausgeführt werden als auf x86 basierende Geräte, da für ARM keine Hardwarebeschleunigung verfügbar ist.|x86, x86_64, arm, arm64|
|`hw.cpu.model`|**CPU-Modell** &ndash; dieser Wert bleibt normalerweise nicht festgelegt (wird für Sie festgelegt, der ein Wert, der von abgeleitet ist `hw.cpu.arch` , wenn sie nicht explizit festgelegt ist). Für die experimentelle Verwendung kann der Wert jedoch auf eine für einen Emulator spezifische Zeichenfolge festgelegt werden.||
|`hw.dPad`|**Steuerkreuz Schlüssel** &ndash; bestimmt, ob das emulierte Gerät Steuerkreuz (DPad) Schlüssel unterstützt. Ein Steuerkreuz besitzt normalerweise vier Tasten, um die Richtung zu steuern.|yes, no|
|`hw.gps`|**GPS-Unterstützung** &ndash; bestimmt, ob das emulierte Gerät einen GPS (Global Positioning System)-Empfänger verfügt.|yes, no|
|`hw.gpu.enabled`|**GPU-Emulation** &ndash; bestimmt, ob das emulierte Gerät die GPU-Emulation unterstützt. Wenn die GPU-Emulation aktiviert ist, wird Open GL for Embedded Systems (Open GL ES) zum Rendern von 2D- und 3D-Grafiken auf dem Bildschirm verwendet. Die zugehörige Einstellung für den GPU-Emulationsmodus bestimmt, wie die GPU-Emulation implementiert wird.|yes, no|
|`hw.gpu.mode`|**GPU-Emulationsmodus** &ndash; bestimmt, wie die GPU-Emulation vom Emulator implementiert wird. Wenn Sie auf "automatisch" auswählen, wählt der Emulator Hardware- und softwarebeschleunigung basierend auf Ihrer Entwicklungsumgebung für die Computer. Wenn Sie den Host auswählen, verwendet der Emulator Grafikprozessor Ihres Entwicklungscomputers, GPU-Emulation für schnelleres Rendering ausführen. Wenn Ihre GPU nicht kompatibel mit dem Emulator ist aus, und Sie auf Windows sind, können Sie den Winkel anstelle von Host versuchen. Der Winkel-Modus verwendet DirectX, um eine ähnliche Host Leistung bieten. Bei Auswahl der Mesa wird den Emulator die Mesa-3D-Software-Bibliothek verwenden, um Grafiken zu rendern. Wählen Sie Mesa, wenn Sie Probleme beim Rendern über Ihres Entwicklungscomputers Grafikprozessor gewährt haben. Der Modus Swiftshader kann zum Rendern von Grafiken in Software mit einer etwas geringeren Leistung als die Verwendung der GPU Ihres Computers verwendet werden. Die off-Option (Hardwareemulation von deaktivieren Grafiken) ist eine veraltete Option, die dazu unsachgemäßes Rendern für einige Elemente und wird daher nicht empfohlen.|auto, host, mesa, angle, swiftshader, off|
|`hw.gsmModem`|**Unterstützung von GSM-Modems** &ndash; bestimmt, ob das emulierte Gerät ein Modem enthält, die das GSM (Global System for Mobile Communications) für Mobilfunknetze unterstützt.|yes, no|
|`hw.initialOrientation`|**Ursprüngliche bildschirmausrichtung** &ndash; konfiguriert Sie die ursprüngliche Ausrichtung des Bildschirms auf dem emulierten Gerät (hoch- oder Querformat-Modus). Im Hochformat ist der Bildschirm höher als er breit ist. Im Querformat ist der Bildschirm breiter als er hoch ist. Wenn das emulierte Gerät ausgeführt wird, können Sie die Ausrichtung ändern, wenn Hoch- und Querformat im Geräteprofil unterstützt werden.|portrait, landscape|
|`hw.keyboard`|**Tastaturunterstützung** &ndash; bestimmt, ob das emulierte Gerät eine QWERTY-Tastatur unterstützt.|yes, no|
|`hw.keyboard.charmap`|**Tastatur Charmap Namen** &ndash; den Namen des der hardwarezeichentabelle für dieses Gerät. Hinweis: Dies sollte immer die Standardeinstellung sein **qwerty2** , wenn Sie das Systemabbild entsprechend geändert haben. Dieser Name wird zur Startzeit an den Kernel gesendet. Das Verwenden eines falschen Namens führt dazu, dass das virtuelle Gerät nicht verwendbar ist.||
|`hw.keyboard.lid`|**Unterstützung** &ndash; Wenn Bildschirmtastatur-Unterstützung aktiviert ist, bestimmt diese Einstellung gibt an, ob die QWERTY-Tastatur geschlossen/ausgeblendet kann werden oder geöffnet/angezeigt. Diese Einstellung wird ignoriert werden, wenn hw.keyboard auf "false" festgelegt ist. Hinweis: der Standardwert ist false, wenn das emulierte Gerät die API-Ebene 12 oder höher ausgerichtet ist.|yes, no|
|`hw.lcd.backlight`|**LCD-hintergrundbeleuchtung** &ndash; bestimmt, ob eine LCD-hintergrundbeleuchtung vom emulierten Gerät simuliert wird.|yes, no|
|`hw.lcd.density`|**LCD-Dichte** &ndash; die Dichte der emulierten LCD-Anzeige, gemessen in Dichte unabhängigen Pixeln oder Verteilungspunkt (dp ist eine virtuelle pixeleinheit). Wenn die Einstellung auf 160 dp festgelegt wird, entspricht jedes dp einem physischen Pixel. Zur Laufzeit verwendet Android diesen Wert, um die entsprechenden Ressourcen bzw. Objekte auszuwählen und für das richtige Rendering der Anzeige zu skalieren.|120, 160, 240, 213, 320|
|`hw.lcd.depth`|**LCD-Farbtiefe** &ndash; -Farbtiefe des emulierten framepuffers, der die Bitmap zum Steuern der LCD-Anzeige enthält. Dieser Wert kann 16 Bit (65.536 mögliche Farben) oder 32 Bit (16.777.216 Farben plus Transparenz) betragen. Die Einstellung für 32 Bit kann die Ausführung des Emulators etwas verlangsamen, dafür wird die Genauigkeit der Farben verbessert.|16, 32|
|`hw.lcd.height`|**LCD-Pixelhöhe** &ndash; die Anzahl der Pixel, die die vertikale Dimension der emulierten LCD-Anzeige bilden.||
|`hw.lcd.width`|**LCD-Pixelbreite** &ndash; die Anzahl der Pixel, die die horizontale Dimension der emulierten LCD-Anzeige bilden.||
|`hw.mainKeys`|**Hardware Back/Home Schlüssel** &ndash; bestimmt, ob das emulierte Gerät wieder Hardware unterstützt und Home-Navigationsschaltflächen. Sie können diesen Wert festlegen, um **Ja** , wenn die Schaltflächen nur in der Software implementiert werden. Wenn `hw.mainKeys` nastaven NA hodnotu **Ja**, der Emulator zeigt keine Navigationsschaltflächen auf dem Bildschirm, aber Sie können die Seitenleiste des Emulators verwenden, auf diese Schaltflächen "drücken".|yes, no|
|`hw.ramSize`|**Gerät RAM-Größe** &ndash; die Größe des physischen Arbeitsspeichers auf dem emulierten Gerät in Megabyte. Der Standardwert wird aus der Bildschirmgröße oder der Version der Skin berechnet. Das Erhöhen der Größe kann dazu führen, dass die Vorgänge des Emulators schneller ausgeführt werden. Dadurch werden jedoch mehr Ressourcen vom Entwicklungscomputer beansprucht.||
|`hw.screen`|**Touchscreens** &ndash; definiert die Art des Bildschirms auf dem emulierten Gerät. Ein Mehrfingereingabe-Bildschirm kann zwei oder mehr Finger auf der touchoberfläche nachverfolgen. Einem Touchscreen kann nur einem Finger Berührungsereignisse erkennen. Ein ohne-Touch-Bildschirm erkennt keine touchereignisse.|touch, multi-touch, no-touch|
|`hw.sdCard`|**Unterstützung für SD-Karten:** &ndash; bestimmt, ob das emulierte Gerät das Einfügen und Entfernen von virtuellen SD (Secure Digital)-Karten unterstützt. Der Emulator verwendet bereitstellbare Datenträgerimages, die auf dem Entwicklungscomputer gespeichert, um die Partitionen der tatsächlichen SD-Kartengeräte zu simulieren (Siehe hw.sdCard.path).|yes, no|
|`sdcard.size`|**Größe der SD-Karten:** &ndash; gibt die Größe der virtuellen SD-Kartendatei an dem vom angegebenen Speicherort `hw.sdCard.path`. auf dem Gerät (in Byte) verfügbar. Wenn dieser Wert eine ganze Zahl ist, gibt es die Größe in Bytes. Sie können auch die Größe in Kilobyte, Megabyte oder Gigabyte angeben, durch Anfügen **K**, **M**, oder **G** auf den Wert. Die minimale Größe beträgt **9 Min.** und die maximale Größe beträgt **1023 GB**.||
|`hw.sdCard.path`|**Imagepfad** &ndash; gibt den Dateinamen und Pfad zu einer Bilddatei auf Ihrem Entwicklungscomputer SD-Karte Partition. Beispielsweise konnte diesen Pfad festgelegt werden, um **C:\sd\sdcard.img** auf Windows.||
|`hw.sensors.magnetic_field`|**Sensor für Magnetfelder** &ndash; bestimmt, ob das emulierte Gerät einen Sensor für Magnetfelder unterstützt. Der Sensor für Magnetfelder (auch als Magnetometer bekannt) meldet das geomagnetische Feld der Umgebung, die von drei Sensorachsen gemessen werden. Aktivieren Sie diese Einstellung für Apps, die Zugriff auf das Lesen von Kompassen benötigen. Eine Navigations-App kann diesen Sensor beispielsweise verwenden, um die Richtung des Benutzers zu erkennen.|yes, no|
|`hw.sensors.orientation`|**Ausrichtungssensor** &ndash; bestimmt, ob das emulierte Gerät Ausrichtung Sensorwerte bereitstellt. Der Ausrichtungssensor misst den Grad der Drehung des Geräts um alle drei physischen Achsen (x, y, z). Beachten Sie, dass der Ausrichtungssensor seit Android 2.2 (API-Ebene 8) veraltet ist.|yes, no|
|`hw.sensors.proximity`|**Näherungssensor:** &ndash; bestimmt, ob das emulierte Gerät einen näherungssensor unterstützt. Dieser Sensor misst die Näherung eines Objekts relativ zum Bildschirm eines Geräts. Dieser Sensor wird üblicherweise verwendet, um zu bestimmen, ob ein Mobilgerät auf der Höhe des Ohrs einer Person gehalten wird.|yes, no|
|`hw.sensors.temperature`|**Temperatursensor** &ndash; bestimmt, ob das emulierte Gerät einen Temperatursensor unterstützt. Dieser Sensor misst die Temperatur des Geräts in Grad Celsius (&deg;C).|yes, no|
|`hw.touchScreen`|**Touchscreenunterstützung:** &ndash; bestimmt, ob das emulierte Gerät einen Touchscreen unterstützt. Der Touchscreen wird für die direkte Bearbeitung des Objekts auf dem Bildschirm verwendet.|yes, no|
|`hw.trackBall`|**Trackballunterstützung** &ndash; bestimmt, ob das emulierte Gerät einen Trackball unterstützt.|yes, no|
|`hw.useext4`|**Unterstützung des EXT4** &ndash; bestimmt, ob das emulierte Gerät das Linux EXT4-Dateisystem für Partitionen verwendet. Da der Typ des Dateisystems mittlerweile automatisch erkannt wird, ist diese Option veraltet und wird ignoriert.|nein|
|`kernel.newDeviceNaming`|**Neue gerätebenennung Kernel** &ndash; verwendet, um anzugeben, ob der Kernel ein neues Benennungsschema für Geräte erfordert. Diese Eigenschaft wird üblicherweise mit Kernels von Linux 3.10 und höher verwendet. Wenn auf festgelegt **Autodetect**, erkennt der Emulator automatisch, ob der Kernel ein neues Benennungsschema für Geräte erfordert.|autodetect, yes, no|
|`kernel.parameters`|**Kernel-Parameter** &ndash; gibt die Zeichenfolge des Linux-Kernel-Boot-Parameter. Diese Einstellung bleibt standardmäßig leer.||
|`kernel.path`|**Kernelpfad** &ndash; gibt den Pfad zu den Linux-Kernel. Wenn dieser Pfad nicht angegeben wird, durchsucht der Emulator das Systemverzeichnis des Emulators für Kernel-Ranchu.||
|`kernel.supportsYaffs2`|**Unterstützung der YAFFS2-Partition** &ndash; bestimmt, ob der Kernel YAFFS2 unterstützt (noch eine andere Flash File System 2) Partitionen. Dies gilt in der Regel nur für Kernels vor Linux 3.10. Wenn auf festgelegt **Autodetect** erkennt der Emulator automatisch, ob der Kernel YAFFS2-Dateisysteme einlegen kann.|autodetect, yes, no|
|`skin.name`|**Name der Skin** &ndash; den Namen für ein Android-Emulator eine Skin. Bei einer Skin handelt es sich um eine Sammlung von Dateien, die die visuellen Elemente und Steuerelemente der Anzeige eines Emulators definiert. Sie beschreibt, wie das Fenster des virtuellen Android-Geräts auf Ihrem Entwicklungscomputer angezeigt wird. Eine Skin beschreibt die Bildschirmgröße, die Schaltflächen und das gesamte Design, hat jedoch keine Auswirkungen auf die Ausführung Ihrer App.||
|`skin.path`|**Pfad zur Skin** &ndash; Pfad zu dem Verzeichnis mit den Emulator eine Skin für Dateien in angegebenen skin.name dieses Verzeichnis enthält hardware.ini Layout-Dateien sowie Bilddateien für die angezeigten Elemente der Skin.||
|`skin.dynamic`|**Skindynamik** &ndash; angibt, ob die Skin dynamisch ist. Bei der Skin des Emulators handelt es sich um eine dynamische Skin, wenn der Emulator eine Skin einer bestimmten Größe erstellen soll, die auf einer angegebenen Breite und Höhe basiert.|nein|

